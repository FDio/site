<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Getting started &mdash; The Vector Packet Processor v22.02-rc0-128-g4450b03ba
 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/rules.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Getting a Patch Reviewed" href="../../contributing/gitreview.html" />
    <link rel="prev" title="Examples" href="examples_doc.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> The Vector Packet Processor
            <img src="../../_static/fd-io_red_white.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                v22.02-rc0-128-g4450b03ba

              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About VPP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/scalar-vs-vector-packet-processing.html">Scalar vs Vector packet processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/extensible.html">The Packet Processing Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/networkstack.html">Network Stack Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/hoststack.html">Host Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/developer.html">Additional features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/supported.html">Supported archs and OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/performance.html">Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/releasenotes/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/featurelist.html">VPP Supported Features</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Use Cases</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/containers/index.html">VPP with Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/simpleperf/index.html">VPP with Iperf3 and TRex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/vppcloud/index.html">VPP in the Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/vhost/index.html">VPP with Virtual Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/vmxnet3.html">VPP with VMware/Vmxnet3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/home_gateway.html">VPP as a Home Gateway</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/acls.html">Access Control Lists with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/networksim.html">Generating traffic with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/webapp.html">Web applications with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/container_test.html">Simulating networks with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/trafficgen.html">Stateless Traffic Gen with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/ikev2/index.html">IKEv2 with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/contiv/index.html">VPP in kubernetes (Contiv/Deprecated)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/installing/index.html">Downloading and Installing VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/running/index.html">Running VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/progressivevpp/index.html">Progressive VPP Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/troubleshooting/index.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer/build-run-debug/index.html">Build, Run &amp; Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/corearchitecture/index.html">Core Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/corefeatures/index.html">Core Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/plugindoc/index.html">Adding a new plugin or feature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/devicedrivers/index.html">Device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/tests/overview.html">VPP Test Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/extras/index.html">VPP extra tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfacing with VPP</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../binapi/index.html">The binary API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c/index.html">C api client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp/index.html">C++ api client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go/index.html">Go api (govpp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust api client</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Memif library (libmemif)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="libmemif_doc.html">Shared Memory Packet Interface (memif) Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="buildinstructions_doc.html">Build Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_setup_doc.html">Example setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples_doc.html">Examples</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Getting started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#zero-copy-slave">Zero-copy Slave</a></li>
<li class="toctree-l3"><a class="reference internal" href="#custom-event-polling">Custom Event Polling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-threading">Multi Threading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#connection-establishment">Connection establishment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#packet-handling">Packet handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-layout">Shared Memory Layout</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/gitreview.html">Getting a Patch Reviewed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/writingdocs.html">Writing VPP Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/reportingissues/index.html">Reporting Bugs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Debug CLI</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli-reference/gettingstarted/index.html">Getting Started with the debug CLI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli-reference/interface/index.html">Interface Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli-reference/index.html">Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Configuration file</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../configuration/config_getting_started.html">Getting started with the configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration/reference.html">Configuration Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Vector Packet Processor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Memif library (libmemif)</a> &raquo;</li>
      <li>Getting started</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/interfacing/libmemif/gettingstarted_doc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="getting-started">
<span id="libmemif-gettingstarted-doc"></span><h1>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline"></a></h1>
<p>For detailed information on api calls and structures please refer to
<code class="docutils literal notranslate"><span class="pre">libmemif.h</span></code>.</p>
<p>Start by creating a memif socket. Memif socket represents UNIX domain
socket and interfaces assigned to use this socket. Memif uses UNIX domain
socket to communicate with other memif drivers.</p>
<p>First fill out the <code class="docutils literal notranslate"><span class="pre">memif_socket_args</span></code> struct. The minimum required
configuration is the UNIX socket path. &gt; Use <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> or <code class="docutils literal notranslate"><span class="pre">\0</span></code> at the
beginning of the path to use abstract socket.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">memif_socket_args_t</span><span class="w"> </span><span class="n">sargs</span><span class="p">;</span><span class="w"></span>

<span class="n">strncpy</span><span class="p">(</span><span class="n">sargs</span><span class="p">.</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">socket_path</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sargs</span><span class="p">.</span><span class="n">path</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">memif_socket_handle_t</span><span class="w"> </span><span class="n">memif_socket</span><span class="p">;</span><span class="w"></span>

<span class="n">memif_create_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memif_socket</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sargs</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">private_data</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Once you have created your socket, you can create memif interfaces on
this socket. Fill out the <code class="docutils literal notranslate"><span class="pre">memif_conn_args</span></code> struct. Then call
<code class="docutils literal notranslate"><span class="pre">memif_create()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">memif_conn_args_t</span><span class="w"> </span><span class="n">cargs</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Assign your socket handle */</span><span class="w"></span>
<span class="n">cargs</span><span class="p">.</span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_socket</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">memif_conn_handle_t</span><span class="w"> </span><span class="n">conn</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Assign callbacks */</span><span class="w"></span>
<span class="n">memif_create</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cargs</span><span class="p">,</span><span class="w"> </span><span class="n">on_connect_cb</span><span class="p">,</span><span class="w"> </span><span class="n">on_disconnect_cb</span><span class="p">,</span><span class="w"> </span><span class="n">on_interrupt_cb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">private_data</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Now start the polling events using libmemifs builtin polling.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_poll_event</span><span class="p">(</span><span class="n">memif_socket</span><span class="p">,</span><span class="w"> </span><span class="cm">/* timeout -1 = blocking */</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Polling can be canceled by calling <code class="docutils literal notranslate"><span class="pre">memif_cancel_poll_event()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">memif_cancel_poll_event</span><span class="w"> </span><span class="p">(</span><span class="n">memif_socket</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>On link status change <code class="docutils literal notranslate"><span class="pre">on_connect</span></code> and <code class="docutils literal notranslate"><span class="pre">on_disconnect</span></code> callbacks are
called respectively. Before you can start transmitting data you, first
need to call <code class="docutils literal notranslate"><span class="pre">memif_refill_queue()</span></code> for each RX queue to initialize
this queue.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">on_connect</span><span class="w"> </span><span class="p">(</span><span class="n">memif_conn_handle_t</span><span class="w"> </span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private_ctx</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">my_private_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">my_private_data_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">private_ctx</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_refill_queue</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="p">(</span><span class="s">&quot;memif_refill_queue: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">   * Do stuff.</span>
<span class="cm">   */</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Now you are ready to transmit packets. &gt; Example implementation
<code class="docutils literal notranslate"><span class="pre">examples/common/sender.c</span></code> and <code class="docutils literal notranslate"><span class="pre">examples/common/responder.c</span></code></p>
<p>To transmit or receive data you will need to use <code class="docutils literal notranslate"><span class="pre">memif_buffer</span></code>
struct. The important fields here are <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">len</span></code>
and <code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">flags</span></code>. The <code class="docutils literal notranslate"><span class="pre">data</span></code> pointer points directly to the
shared memory packet buffer. This is where you will find/insert your
packets. The <code class="docutils literal notranslate"><span class="pre">len</span></code> field is the length of the buffer. If the flag
<code class="docutils literal notranslate"><span class="pre">MEMIF_BUFFER_FLAG_NEXT</span></code> is present in <code class="docutils literal notranslate"><span class="pre">flags</span></code> field, this buffer is
chained so the rest of the data is located in the next buffer, and so
on.</p>
<p>First let’s receive data. To receive data call <code class="docutils literal notranslate"><span class="pre">memif_rx_burst()</span></code>. The
function will fill out memif buffers passed to it. Then you would
process your data (e.g. copy to your stack). Last you must refill the
queue using <code class="docutils literal notranslate"><span class="pre">memif_refill_queue()</span></code> to notify peer that the buffers are
now free and can be overwritten.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Fill out memif buffers and mark them as received */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_rx_burst</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">buffers</span><span class="p">,</span><span class="w"> </span><span class="n">num_buffers</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num_received</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;memif_rx_burst: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cm">/*</span>
<span class="cm">    Process the buffers.</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cm">/* Refill the queue, so that the peer interface can transmit more packets */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_refill_queue</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">num_received</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="p">(</span><span class="s">&quot;memif_refill_queue: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In order to transmit data you first need to ‘allocate’ memif buffers
using <code class="docutils literal notranslate"><span class="pre">memif_buffer_alloc()</span></code>. This function similar to
<code class="docutils literal notranslate"><span class="pre">memif_rx_burst</span></code> will fill out provided memif buffers. You will then
insert your packets directly into the shared memory (don’t forget to
update <code class="docutils literal notranslate"><span class="pre">len</span></code> filed if your packet is smaller that buffer length).
Finally call <code class="docutils literal notranslate"><span class="pre">memif_tx_burst</span></code> to transmit the buffers.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Alocate memif buffers */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_buffer_alloc</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">buffers</span><span class="p">,</span><span class="w"> </span><span class="n">num_pkts</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num_allocated</span><span class="p">,</span><span class="w"> </span><span class="n">packet_size</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="p">(</span><span class="s">&quot;memif_buffer_alloc: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">    Fill out the buffers.</span>

<span class="cm">    tx_buffers[i].data field points to the shared memory.</span>
<span class="cm">    update tx_buffers[i].len to your packet length, if the packet is smaller.</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cm">/* Transmit the buffers */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_tx_burst</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">buffers</span><span class="p">,</span><span class="w"> </span><span class="n">num_allocated</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num_transmitted</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="p">(</span><span class="s">&quot;memif_tx_burst: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="zero-copy-slave">
<h2>Zero-copy Slave<a class="headerlink" href="#zero-copy-slave" title="Permalink to this headline"></a></h2>
<p>Interface with slave role is the buffer producer, as such it can use
zero-copy mode.</p>
<p>After receiving buffers, process your packets in place. Then use
<code class="docutils literal notranslate"><span class="pre">memif_buffer_enq_tx()</span></code> to enqueue rx buffers to tx queue (by swapping
rx buffer with a free tx buffer).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Fill out memif buffers and mark them as received */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_rx_burst</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">buffers</span><span class="p">,</span><span class="w"> </span><span class="n">num_buffers</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num_received</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;memif_rx_burst: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">    Process the buffers in place.</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cm">/* Enqueue processed buffers to tx queue */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_buffer_enq_tx</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">buffers</span><span class="p">,</span><span class="w"> </span><span class="n">num_buffers</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num_enqueued</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="p">(</span><span class="s">&quot;memif_buffer_alloc: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Refill the queue, so that the peer interface can transmit more packets */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_refill_queue</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">num_enqueued</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="p">(</span><span class="s">&quot;memif_refill_queue: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Transmit the buffers. */</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memif_tx_burst</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="n">qid</span><span class="p">,</span><span class="w"> </span><span class="n">buffers</span><span class="p">,</span><span class="w"> </span><span class="n">num_enqueued</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num_transmitted</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MEMIF_ERR_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">INFO</span><span class="p">(</span><span class="s">&quot;memif_tx_burst: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">memif_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="custom-event-polling">
<h2>Custom Event Polling<a class="headerlink" href="#custom-event-polling" title="Permalink to this headline"></a></h2>
<p>Libmemif can be integrated into your applications fd event polling. You
will need to implement <code class="docutils literal notranslate"><span class="pre">memif_control_fd_update_t</span></code> callback and pass
it to <code class="docutils literal notranslate"><span class="pre">memif_socket_args.on_control_fd_update</span></code>. Now each time any file
descriptor belonging to that socket updates, <code class="docutils literal notranslate"><span class="pre">on_control_fd_update</span></code>
callback is called. The file descriptor and event type is passed in
<code class="docutils literal notranslate"><span class="pre">memif_fd_event_t</span></code>. It also contains private context that is
associated with this fd. When event is polled on the fd you need to call
<code class="docutils literal notranslate"><span class="pre">memif_control_fd_handler</span></code> and pass the event type and private context
associated with the fd.</p>
</section>
<section id="multi-threading">
<h2>Multi Threading<a class="headerlink" href="#multi-threading" title="Permalink to this headline"></a></h2>
<section id="connection-establishment">
<h3>Connection establishment<a class="headerlink" href="#connection-establishment" title="Permalink to this headline"></a></h3>
<p>Memif sockets should not be handled in parallel. Instead each thread
should have it’s own socket. However the UNIX socket can be the same. In
case of non-listener socket, it’s straight forward, just create the
socket using the same path. In case of listener socket, the polling
should be done by single thread. &gt; The socket becomes listener once a
Master interface is assigned to it.</p>
</section>
<section id="packet-handling">
<h3>Packet handling<a class="headerlink" href="#packet-handling" title="Permalink to this headline"></a></h3>
<p>Single queue must not be handled in parallel. Instead you can assign
queues to threads in such way that each queue is only assigned single
thread.</p>
</section>
</section>
<section id="shared-memory-layout">
<h2>Shared Memory Layout<a class="headerlink" href="#shared-memory-layout" title="Permalink to this headline"></a></h2>
<p>Please refer to <a class="reference external" href="http://doc.dpdk.org/guides/nics/memif.html">DPDK MEMIF
documentation</a>
<code class="docutils literal notranslate"><span class="pre">'Shared</span> <span class="pre">memory'</span></code> section.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="examples_doc.html" class="btn btn-neutral float-left" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../contributing/gitreview.html" class="btn btn-neutral float-right" title="Getting a Patch Reviewed" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2021, Linux Foundation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>