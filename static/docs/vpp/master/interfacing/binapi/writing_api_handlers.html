<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Writing API handlers &mdash; The Vector Packet Processor v22.02-rc0-128-g4450b03ba
 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/rules.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="C api client" href="../c/index.html" />
    <link rel="prev" title="VPP API Language" href="vpp_api_language.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> The Vector Packet Processor
            <img src="../../_static/fd-io_red_white.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                v22.02-rc0-128-g4450b03ba

              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About VPP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/scalar-vs-vector-packet-processing.html">Scalar vs Vector packet processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/extensible.html">The Packet Processing Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/networkstack.html">Network Stack Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/hoststack.html">Host Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/developer.html">Additional features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/supported.html">Supported archs and OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/performance.html">Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/releasenotes/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutvpp/featurelist.html">VPP Supported Features</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Use Cases</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/containers/index.html">VPP with Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/simpleperf/index.html">VPP with Iperf3 and TRex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/vppcloud/index.html">VPP in the Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/vhost/index.html">VPP with Virtual Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/vmxnet3.html">VPP with VMware/Vmxnet3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/home_gateway.html">VPP as a Home Gateway</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/acls.html">Access Control Lists with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/networksim.html">Generating traffic with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/webapp.html">Web applications with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/container_test.html">Simulating networks with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/trafficgen.html">Stateless Traffic Gen with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/ikev2/index.html">IKEv2 with VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/contiv/index.html">VPP in kubernetes (Contiv/Deprecated)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/installing/index.html">Downloading and Installing VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/running/index.html">Running VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/progressivevpp/index.html">Progressive VPP Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/troubleshooting/index.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer/build-run-debug/index.html">Build, Run &amp; Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/corearchitecture/index.html">Core Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/corefeatures/index.html">Core Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/plugindoc/index.html">Adding a new plugin or feature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/devicedrivers/index.html">Device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/tests/overview.html">VPP Test Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/extras/index.html">VPP extra tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfacing with VPP</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The binary API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="vpp_api_module.html">VPP API module</a></li>
<li class="toctree-l2"><a class="reference internal" href="vpp_api_language.html">VPP API Language</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Writing API handlers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#message-allocation">Message Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-tracing-and-replay">Message Tracing and Replay</a></li>
<li class="toctree-l3"><a class="reference internal" href="#client-connection-details">Client connection details</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#binary-api-message-rx-pthread">binary API message RX pthread</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#client-disconnection-details">Client disconnection details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sending-binary-api-messages-to-vpp">Sending binary API messages to VPP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#receiving-binary-api-messages-from-vpp">Receiving binary API messages from VPP</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../c/index.html">C api client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp/index.html">C++ api client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go/index.html">Go api (govpp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust api client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libmemif/index.html">Memif library (libmemif)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/gitreview.html">Getting a Patch Reviewed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/writingdocs.html">Writing VPP Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/reportingissues/index.html">Reporting Bugs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Debug CLI</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli-reference/gettingstarted/index.html">Getting Started with the debug CLI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli-reference/interface/index.html">Interface Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli-reference/index.html">Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Configuration file</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../configuration/config_getting_started.html">Getting started with the configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration/reference.html">Configuration Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Vector Packet Processor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">The binary API</a> &raquo;</li>
      <li>Writing API handlers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/interfacing/binapi/writing_api_handlers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="writing-api-handlers">
<span id="api-doc"></span><h1>Writing API handlers<a class="headerlink" href="#writing-api-handlers" title="Permalink to this headline"></a></h1>
<p>VPP provides a binary API scheme to allow a wide variety of client codes
to program data-plane tables. As of this writing, there are hundreds of
binary APIs.</p>
<p>Messages are defined in <code class="docutils literal notranslate"><span class="pre">*.api</span></code> files. Today, there are about 50 api
files, with more arriving as folks add programmable features. The API
file compiler sources reside in &#64;ref src/tools/vppapigen.</p>
<p>From &#64;ref src/vnet/interface.api, here’s a typical request/response
message definition:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">autoreply</span><span class="w"> </span><span class="n">define</span><span class="w"> </span><span class="n">sw_interface_set_flags</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">client_index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">sw_if_index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* 1 = up, 0 = down */</span><span class="w"></span>
<span class="w">  </span><span class="n">u8</span><span class="w"> </span><span class="n">admin_up_down</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>To a first approximation, the API compiler renders this definition into
<code class="docutils literal notranslate"><span class="pre">build-root/.../vpp/include/vnet/interface.api.h</span></code> as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/****** Message ID / handler enum ******/</span><span class="w"></span>
<span class="cp">#ifdef vl_msg_id</span>
<span class="n">vl_msg_id</span><span class="p">(</span><span class="n">VL_API_SW_INTERFACE_SET_FLAGS</span><span class="p">,</span><span class="w"> </span><span class="n">vl_api_sw_interface_set_flags_t_handler</span><span class="p">)</span><span class="w"></span>
<span class="n">vl_msg_id</span><span class="p">(</span><span class="n">VL_API_SW_INTERFACE_SET_FLAGS_REPLY</span><span class="p">,</span><span class="w"> </span><span class="n">vl_api_sw_interface_set_flags_reply_t_handler</span><span class="p">)</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cm">/****** Message names ******/</span><span class="w"></span>
<span class="cp">#ifdef vl_msg_name</span>
<span class="n">vl_msg_name</span><span class="p">(</span><span class="n">vl_api_sw_interface_set_flags_t</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">vl_msg_name</span><span class="p">(</span><span class="n">vl_api_sw_interface_set_flags_reply_t</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cm">/****** Message name, crc list ******/</span><span class="w"></span>
<span class="cp">#ifdef vl_msg_name_crc_list</span>
<span class="cp">#define foreach_vl_msg_name_crc_interface \</span>
<span class="cp">_(VL_API_SW_INTERFACE_SET_FLAGS, sw_interface_set_flags, f890584a) \</span>
<span class="cp">_(VL_API_SW_INTERFACE_SET_FLAGS_REPLY, sw_interface_set_flags_reply, dfbf3afa) \</span>
<span class="cp">#endif</span>

<span class="cm">/****** Typedefs *****/</span><span class="w"></span>
<span class="cp">#ifdef vl_typedefs</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">VL_API_PACKED</span><span class="p">(</span><span class="k">struct</span> <span class="nc">_vl_api_sw_interface_set_flags</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">u16</span><span class="w"> </span><span class="n">_vl_msg_id</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">client_index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">sw_if_index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="n">admin_up_down</span><span class="p">;</span><span class="w"></span>
<span class="p">})</span><span class="w"> </span><span class="n">vl_api_sw_interface_set_flags_t</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="n">VL_API_PACKED</span><span class="p">(</span><span class="k">struct</span> <span class="nc">_vl_api_sw_interface_set_flags_reply</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">u16</span><span class="w"> </span><span class="n">_vl_msg_id</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">i32</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span><span class="w"></span>
<span class="p">})</span><span class="w"> </span><span class="n">vl_api_sw_interface_set_flags_reply_t</span><span class="p">;</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* vl_typedefs */</span><span class="cp"></span>
</pre></div>
</div>
<p>To change the admin state of an interface, a binary api client sends a
&#64;ref vl_api_sw_interface_set_flags_t to VPP, which will respond with a
&#64;ref vl_api_sw_interface_set_flags_reply_t message.</p>
<p>Multiple layers of software, transport types, and shared libraries
implement a variety of features:</p>
<ul class="simple">
<li><p>API message allocation, tracing, pretty-printing, and replay.</p></li>
<li><p>Message transport via global shared memory, pairwise/private shared
memory, and sockets.</p></li>
<li><p>Barrier synchronization of worker threads across thread-unsafe
message handlers.</p></li>
</ul>
<p>Correctly-coded message handlers know nothing about the transport used
to deliver messages to/from VPP. It’s reasonably straightforward to use
multiple API message transport types simultaneously.</p>
<p>For historical reasons, binary api messages are (putatively) sent in
network byte order. As of this writing, we’re seriously considering
whether that choice makes sense.</p>
<section id="message-allocation">
<h2>Message Allocation<a class="headerlink" href="#message-allocation" title="Permalink to this headline"></a></h2>
<p>Since binary API messages are always processed in order, we allocate
messages using a ring allocator whenever possible. This scheme is
extremely fast when compared with a traditional memory allocator, and
doesn’t cause heap fragmentation. See &#64;ref
src/vlibmemory/memory_shared.c &#64;ref vl_msg_api_alloc_internal().</p>
<p>Regardless of transport, binary api messages always follow a &#64;ref
msgbuf_t header:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">msgbuf_</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">unix_shared_memory_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">data_len</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">gc_mark_timestamp</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u8</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">msgbuf_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This structure makes it easy to trace messages without having to decode
them - simply save data_len bytes - and allows &#64;ref vl_msg_api_free() to
rapidly dispose of message buffers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"></span>
<span class="nf">vl_msg_api_free</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">msgbuf_t</span><span class="w"> </span><span class="o">*</span><span class="n">rv</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">api_main_t</span><span class="w"> </span><span class="o">*</span><span class="n">am</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">api_main</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">msgbuf_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(((</span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offsetof</span><span class="w"> </span><span class="p">(</span><span class="n">msgbuf_t</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">   * Here&#39;s the beauty of the scheme.  Only one proc/thread has</span>
<span class="cm">   * control of a given message buffer. To free a buffer, we just</span>
<span class="cm">   * clear the queue field, and leave. No locks, no hits, no errors...</span>
<span class="cm">   */</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rv</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">rv</span><span class="o">-&gt;</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">rv</span><span class="o">-&gt;</span><span class="n">gc_mark_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="message-tracing-and-replay">
<h2>Message Tracing and Replay<a class="headerlink" href="#message-tracing-and-replay" title="Permalink to this headline"></a></h2>
<p>It’s extremely important that VPP can capture and replay sizeable binary
API traces. System-level issues involving hundreds of thousands of API
transactions can be re-run in a second or less. Partial replay allows
one to binary-search for the point where the wheels fall off. One can
add scaffolding to the data plane, to trigger when complex conditions
obtain.</p>
<p>With binary API trace, print, and replay, system-level bug reports of
the form “after 300,000 API transactions, the VPP data-plane stopped
forwarding traffic, FIX IT!” can be solved offline.</p>
<p>More often than not, one discovers that a control-plane client
misprograms the data plane after a long time or under complex
circumstances. Without direct evidence, “it’s a data-plane problem!”</p>
<p>See &#64;ref src/vlibmemory/memory_vlib.c &#64;ref vl_msg_api_process_file(),
and &#64;ref src/vlibapi/api_shared.c. See also the debug CLI command “api
trace”</p>
</section>
<section id="client-connection-details">
<h2>Client connection details<a class="headerlink" href="#client-connection-details" title="Permalink to this headline"></a></h2>
<p>Establishing a binary API connection to VPP from a C-language client is
easy:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"></span>
<span class="nf">connect_to_vpe</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">client_name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">client_message_queue_length</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">vat_main_t</span><span class="w"> </span><span class="o">*</span><span class="n">vam</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vat_main</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">api_main_t</span><span class="w"> </span><span class="o">*</span><span class="n">am</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">api_main</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vl_client_connect_to_vlib</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;/vpe-api&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">client_name</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">client_message_queue_length</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* Memorize vpp&#39;s binary API message input queue address */</span><span class="w"></span>
<span class="w">  </span><span class="n">vam</span><span class="o">-&gt;</span><span class="n">vl_input_queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">am</span><span class="o">-&gt;</span><span class="n">shmem_hdr</span><span class="o">-&gt;</span><span class="n">vl_input_queue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* And our client index */</span><span class="w"></span>
<span class="w">  </span><span class="n">vam</span><span class="o">-&gt;</span><span class="n">my_client_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">am</span><span class="o">-&gt;</span><span class="n">my_client_index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>32 is a typical value for client_message_queue_length. VPP cannot block
when it needs to send an API message to a binary API client, and the
VPP-side binary API message handlers are very fast. When sending
asynchronous messages, make sure to scrape the binary API rx ring with
some enthusiasm.</p>
<section id="binary-api-message-rx-pthread">
<h3>binary API message RX pthread<a class="headerlink" href="#binary-api-message-rx-pthread" title="Permalink to this headline"></a></h3>
<p>Calling &#64;ref vl_client_connect_to_vlib spins up a binary API message RX
pthread:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="nf">rx_thread_fn</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">unix_shared_memory_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">memory_client_main_t</span><span class="w"> </span><span class="o">*</span><span class="n">mm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory_client_main</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">api_main_t</span><span class="w"> </span><span class="o">*</span><span class="n">am</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">api_main</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">am</span><span class="o">-&gt;</span><span class="n">vl_input_queue</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* So we can make the rx thread terminate cleanly */</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">setjmp</span><span class="w"> </span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rx_thread_jmpbuf</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rx_thread_jmpbuf_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">vl_msg_api_queue_handler</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">pthread_exit</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>To handle the binary API message queue yourself, use &#64;ref
vl_client_connect_to_vlib_no_rx_pthread.</p>
<p>In turn, vl_msg_api_queue_handler(…) uses mutex/condvar signalling to
wake up, process VPP -&gt; client traffic, then sleep. VPP supplies a
condvar broadcast when the VPP -&gt; client API message queue transitions
from empty to nonempty.</p>
<p>VPP checks its own binary API input queue at a very high rate. VPP
invokes message handlers in “process” context [aka cooperative
multitasking thread context] at a variable rate, depending on data-plane
packet processing requirements.</p>
</section>
</section>
<section id="client-disconnection-details">
<h2>Client disconnection details<a class="headerlink" href="#client-disconnection-details" title="Permalink to this headline"></a></h2>
<p>To disconnect from VPP, call &#64;ref vl_client_disconnect_from_vlib. Please
arrange to call this function if the client application terminates
abnormally. VPP makes every effort to hold a decent funeral for dead
clients, but VPP can’t guarantee to free leaked memory in the shared
binary API segment.</p>
</section>
<section id="sending-binary-api-messages-to-vpp">
<h2>Sending binary API messages to VPP<a class="headerlink" href="#sending-binary-api-messages-to-vpp" title="Permalink to this headline"></a></h2>
<p>The point of the exercise is to send binary API messages to VPP, and to
receive replies from VPP. Many VPP binary APIs comprise a client request
message, and a simple status reply. For example, to set the admin status
of an interface, one codes:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">vl_api_sw_interface_set_flags_t</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">;</span><span class="w"></span>

<span class="n">mp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vl_msg_api_alloc</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">));</span><span class="w"></span>
<span class="n">memset</span><span class="w"> </span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">));</span><span class="w"></span>
<span class="n">mp</span><span class="o">-&gt;</span><span class="n">_vl_msg_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clib_host_to_net_u16</span><span class="w"> </span><span class="p">(</span><span class="n">VL_API_SW_INTERFACE_SET_FLAGS</span><span class="p">);</span><span class="w"></span>
<span class="n">mp</span><span class="o">-&gt;</span><span class="n">client_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">api_main</span><span class="p">.</span><span class="n">my_client_index</span><span class="p">;</span><span class="w"></span>
<span class="n">mp</span><span class="o">-&gt;</span><span class="n">sw_if_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clib_host_to_net_u32</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">interface</span><span class="o">-</span><span class="n">sw</span><span class="o">-</span><span class="k">if</span><span class="o">-</span><span class="n">index</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="n">vl_msg_api_send</span><span class="w"> </span><span class="p">(</span><span class="n">api_main</span><span class="p">.</span><span class="n">shmem_hdr</span><span class="o">-&gt;</span><span class="n">vl_input_queue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">mp</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Key points:</p>
<ul class="simple">
<li><p>Use &#64;ref vl_msg_api_alloc to allocate message buffers</p></li>
<li><p>Allocated message buffers are not initialized, and must be presumed
to contain trash.</p></li>
<li><p>Don’t forget to set the _vl_msg_id field!</p></li>
<li><p>As of this writing, binary API message IDs and data are sent in
network byte order</p></li>
<li><p>The client-library global data structure &#64;ref api_main keeps track of
sufficient pointers and handles used to communicate with VPP</p></li>
</ul>
</section>
<section id="receiving-binary-api-messages-from-vpp">
<h2>Receiving binary API messages from VPP<a class="headerlink" href="#receiving-binary-api-messages-from-vpp" title="Permalink to this headline"></a></h2>
<p>Unless you’ve made other arrangements (see &#64;ref
vl_client_connect_to_vlib_no_rx_pthread), <em>messages are received on a
separate rx pthread</em>. Synchronization with the client application main
thread is the responsibility of the application!</p>
<p>Set up message handlers about as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define vl_typedefs     </span><span class="cm">/* define message structures */</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vpp/api/vpe_all_api_h.h&gt;</span><span class="cp"></span>
<span class="cp">#undef vl_typedefs</span>

<span class="cm">/* declare message handlers for each api */</span><span class="w"></span>

<span class="cp">#define vl_endianfun        </span><span class="cm">/* define message structures */</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vpp/api/vpe_all_api_h.h&gt;</span><span class="cp"></span>
<span class="cp">#undef vl_endianfun</span>

<span class="cm">/* instantiate all the print functions we know about */</span><span class="w"></span>
<span class="cp">#define vl_print(handle, ...)</span>
<span class="cp">#define vl_printfun</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vpp/api/vpe_all_api_h.h&gt;</span><span class="cp"></span>
<span class="cp">#undef vl_printfun</span>

<span class="cm">/* Define a list of all message that the client handles */</span><span class="w"></span>
<span class="cp">#define foreach_vpe_api_reply_msg                            \</span>
<span class="cp">   _(SW_INTERFACE_SET_FLAGS_REPLY, sw_interface_set_flags_reply)</span>

<span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="n">clib_error_t</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">   </span><span class="nf">my_api_hookup</span><span class="w"> </span><span class="p">(</span><span class="n">vlib_main_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vm</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">api_main_t</span><span class="w"> </span><span class="o">*</span><span class="n">am</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">api_main</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="cp">#define _(N,n)                                                  \</span>
<span class="cp">       vl_msg_api_set_handlers(VL_API_##N, #n,                     \</span>
<span class="cp">                              vl_api_##n##_t_handler,              \</span>
<span class="cp">                              vl_noop_handler,                     \</span>
<span class="cp">                              vl_api_##n##_t_endian,               \</span>
<span class="cp">                              vl_api_##n##_t_print,                \</span>
<span class="cp">                              sizeof(vl_api_##n##_t), 1);</span>
<span class="w">     </span><span class="n">foreach_vpe_api_msg</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#undef _</span>

<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The key API used to establish message handlers is &#64;ref
vl_msg_api_set_handlers , which sets values in multiple parallel vectors
in the &#64;ref api_main_t structure. As of this writing: not all vector
element values can be set through the API. You’ll see sporadic API
message registrations followed by minor adjustments of this form:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Thread-safe API messages</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">am</span><span class="o">-&gt;</span><span class="n">is_mp_safe</span><span class="p">[</span><span class="n">VL_API_IP_ADD_DEL_ROUTE</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">am</span><span class="o">-&gt;</span><span class="n">is_mp_safe</span><span class="p">[</span><span class="n">VL_API_GET_NODE_GRAPH</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vpp_api_language.html" class="btn btn-neutral float-left" title="VPP API Language" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../c/index.html" class="btn btn-neutral float-right" title="C api client" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2021, Linux Foundation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>